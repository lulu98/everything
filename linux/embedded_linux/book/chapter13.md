# Chapter 13: Development Tools

## GNU Debugger (GDB)

- low-level hardware-specific debugging support for a wide variety of
architectures and microprocessors
- use a version of GDB that has been compiled as a cross-debugger -> the
debugger runs on your development host, but it understands only binary
executables in the architecture for which it was configured at compile time

### Debugging a Core Dump

- core dump:
    * a file generated by the kernel when an application program generates a fault
    * a snapshot of the running process at the time the segmentation fault
    occurred
- `SIGSEGV` (segmentation fault):
    * a Linux kernel signal that is generated on illegal memory access by a user
    process
    * when this signal is generated the kernel terminates the process, then the
    kernel dumps a core image (when enabled)
    * the most common fault that triggers a core dump
- user process must have authority to enable a core dump -> `setrlimit()` C
function, or `ulimit` command from BASH/BusyBox
- typically `ulimit` is set to "unlimited" during system startup, so will just
enable kernel dump for every user space process on fault
- debugging symbols should be enabled in kernel binary during compilation to
properly use GDB
- you can single-step through binary or set breakpoints

## Data Display Debugger (DDD)

- graphical frontend to GDB and other command-line debuggers
- Eclipse is more popular by now

## `cbrowser/cscope`

- support in the Linux kernel source tree
- a simple source-code browsing tool that makes it easy to navigate around a
large source tree following symbols

## Tracing and Profiling Tools

### `strace`

- trace utility
- captures and displays information for every kernel system call executed by a
Linux application program
- can be run on programs for which no source code is availablea
- you can even specify to only trace subsets of system calls, e.g. only
network-related system calls (`stract -e trace=network <process_name>`)
- available subsets of system calls:
    * network-related
    * file-related
    * process-related
    * signal-related
    * IPC-related
- `-f` option to trace child processes spawned through `fork()`
- `-c` option for high-level profiling of application -> accumulates statistics
on each system call, how many times it was encountered, how many errors and time
spent on each system call

### `ltrace`

- similar to `strace` but for library calls instead of system calls
- for each library call, the name of the call is displayed, along with varying
portions of the parameters to the call
- `-c` option for accumulated statistics
- ltrace only available for programs that have been compiled to use dynamically
linked shared library objects

### `ps`

- makes use of `/proc` file system
- present information of `/proc` file system in a convenient human-readable form
- lists all running processes on a machine
- without any options, `ps` displays all processes that have the same user ID as
the user who invoked the command and only the processes that are associated with
the terminal on which the command was issued
- `ps` supports three distinct options styles: BSD (letters, no dash), UNIX (dash-letter
combination), GNU (double dashes with long option format)
- `ps aux` display every process on the system
- `ps` is one-time snapshort of the current system

### `top`

- `top` takes periodic snapshots of the state of system and its processes
- without options, `top` displays all running processes (updated every 3 seconds)

### `mtrace`

- simple utility that analyzes and reports on calls to `malloc()`, `realloc()`,
and `free()` in your application
- `mtrace` package is simple, relatively non-intrusive package most useful for
simple detection of malloc/free unbalance conditions

### `dmalloc`

- `dmalloc` package lets you detect a much wider range of dynamic memory-management
errors
- highly intrusive
- can slow application down -> change timing of application
- powerful dynamic memory-analysis tool
- highly configurable and complex

### Kernel Oops

- kernel oops reults from a variety of kernel errors
- information in a kernel oops message is directly related to the processor ->
having some knowledge of the underlying architecture is necessary to fully
understand the oops message

## Binary Utilities (binutils)

- binutils are a critical component of any toolchain

### `readelf` utility

- examines the composition of your target ELF binary file
- useful if explicit control over image layout is required
- `readelf -s <elf-image>` to display the symbol table in an ELF image
- `readelf -e <elf-image>` to discover and display all the sections in your ELF
image
- common sections:
    * `.text` section: contains the executable program code
    * `.rodata` section: contains constant data in your program
    * `.data` section: contains initialized global data used by the C library
    prologue code and can contain large initialized data items from your
    application
    * `.sdata` section: used for smaller initialized global data items (only on
    some architectures)
    * `.bss` and `.sbss` section: contain uninitialized data -> occupy no space
    in program image, their memory space is allocated and initialized to 0 on
    program startup by C library prologue code
    * `.rodata` section: initialized global variable + all constant strings defined
    in program
- often used to display debug information contained in an ELF image -> `-g` option
- debug information can be very large

### `objdump` utility

- overlap with `readelf`
- capability to display disassembled object code
- if program was compiled as a dynamically linked object, we will not have an
address for the `printf()` function until runtime, when it is linked with the
shared libary `printf()` routine
- if compiled statically, we can see label and address

### `objcopy` utility

- formats and converts the format of a binary object file 

## Miscellaneous Binary Utilities

### `strip` utility

- can be used to remove symbols and debug information from a binary
- used to save space on an embedded device
- keep stripped binaries on target system and leave unstripped version on
development host -> symbols are available for cross-debugging on development
host while saving space on target

### `addr2line` utility

- read the debug information contained in the executable ELF file and display a
line number corresponding to the address

### `strings` utility

- examines ASCII string data in binary files
- can be used to examine memory dumps when source code or debug symbols might
not be available

### `ldd` script

- part of the C library package, exists on every Linux distribution
- lists the shared object library dependencies for a given object file or files

### `nm` utility

- displays symbols from an object file
- format: `<address> <symbol-type> <symbol>`
- symbol types:
    * capital letter indicates a global symbol
    * lowercase letter indicates a local symbol
    * `B`: the symbol is located in the `.bss` section
    * `T`: the symbol is located in the `.text` section
    * `D`: the symbol is located in the `.data` section
    * `A`: this address is absolute and is not subject to modification by an
    additional link stage

### `prelink` utility

- often used in systems where startup time is important
- prepares the shared libraries and the object files that depend on them to
provide a priori knowledge of the unresolved library references -> can reduce
startup time of an application

